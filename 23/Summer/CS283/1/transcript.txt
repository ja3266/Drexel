The C programming language. And this is the language that we will be using exclusively in this course. But before we get into the whys, the wherefores, the how twos in the language. I want to begin by letting you listen to a discussion that talks about the origins of the language, where exactly did see come from. And so for that, I want you to listen to the words of Ken Thompson, one of the people behind the creation of a language. I decided no computer is complete without Fortran. Gotta have Fortran. And nobody will ever buy a computer without a Fortran. Not now, the, the PDB seven was 8 K of 18 bit words. Okay. Yeah. And I ripped off for K for the system, right? That was mine. And and then the users swap through the other four K. And so I was writing Fortran and TMG. I was having a great time. And then the first time I tried to actually do it, it was like ten times the size of the thing over there. So I started cut and pieces out of it. Went down and down and down and down and down. When it finally got down to four K, I called it b. And, and, but it was right at four k because it came from above, right? There's no reason to stop when you get to where you want. So then I'd put features in that I liked and it would blow over four k and not run. So I wrote a separate version of B, which was a virtual be that would run the program out of disk. And so it would grow over four k. I'd run it on virtual be to get the b source that be source for both of them are the same. And hopefully what I wrote was a compaction of some sort, so we get smaller. So go under for k so I can bring it back to being roughly real time kind of a. And this one over and over and over. Until the final version of B. There was one other added thing to be, which was, I saw Johnson's semicolon version of the for loop. And I put that in, I stole it, yeah. And and and and that when virtual and then came back down again. And then Dennis took it and wanted to put it on the comp center of the big calm center. And he wrote a compiler for B for the big calm center. And he called it newbie and NB. Nb. And it was used to some extent and it was externally ported to use several universities. And then he decided that wasn't enough at this point time and gone on. And we now had a PDP 11. And we started getting more memory for the PDP 11 so we could think about expansion. And we decided that we had to write Unix in a higher-level language. It was just mandatory. This was all assembly language digital that so he started muting newbie into C. With the big deal was types. He put types and b, b and b in the old, old C were very, very similar language except for the all the types. Newt be only had words. You load store at. Everything was words and the PDP 11 was bytes. So something had to be done to not waste factor for on, on it. So anyway, long story short, all by himself. He converted that made see I, we then tried to rewrite the kernel and see that whatever this current language was, which was called C and failed three times, three total, complete failures. And basically being an egotist, I blamed it on language. So he'd go back and beef up the language for something. And then finally, when structures came in the way that structures did come into the language which is completely outside of BB, had nothing resembling structures. The port two units of C on the PDP 11 worked. It was, before that it was too complicated. I just couldn't keep it all together. And so then there was the first C version of Unix. And, and C became a pretty, yeah, It's something to do with ceded. Nothing to do its thing. I twisted the guy's arm into writing a book, but that's the sternum. So that a little bit at the end, where CAN turns and says You had something to do with C, Didn't you? The person he was talking to was Brian Kernighan. And when Brian says, Hey, I, all I did was twist somebody's arm into writing a book about it. He's referring to this book right here. The C programming language. This is the book that for all practical purposes defined the language. It is the, in many ways, one of the best books ever on a programming language. It is relatively concise, it is thorough, and it is easy to read. Now. The language itself was then evolved in some sense of the word. One could say devolved. But it did change some. And they came out with a second edition of the book, which looks like this. And so if you pick up a copy of this famous book simply called the C programming language, you'll probably will get a second edition. The authors of it are simply known as k and r. K being Quran, the Brian Carter hand that you saw in the video, the R being Dennis Ritchie. Dennis was the one who Ken was talking about, who took the language B and morphed it, added the capacity of types and added structures and things like that. And once those were in place, as Ken said, it now became the language that was suitable for rewriting the Unix kernel. So why is C so important? Well, the first thing you have to understand is that the perception that is out there. And I hear this all the time from students, that somehow computer science is always moving towards the better and that anything new is better than anything old. First thing you have to understand is that's completely wrong. Almost every good idea that is being used now has been around for a very long time. Most of the techniques that we highlight as new and different are really just revisiting old things that have been around for a very long time. So the C language in many ways is an improvement not only over all of its predecessors, but over all of its successors as well. Why is it such a beautiful language? Well, we'll get into that a little bit more. But I want to start with a quote. Now, this is from a person by the name of Paul Graham. Now I don't know very much about Paul Graham, so I can't I don't present this as an authoritative statement from somebody who I respect. On the other hand, I very much like the way he put it and it very much fits with the view that I have on it. And he writes, this. It seems to me that there have been two really clear, consistent models of programming. The SI model and the model. These two seem to be high points with swampy lowlands in between. I like the way of putting it. That is indeed a pretty good way to look at the language. It is a high point. It is a very elegant and very straightforward language to use. Another person in a recent discussion that was taking place on a mailing list was explaining why his company has gone to using entirely C. Says C and use that language for everything. Specifically, he says, no JavaScript. No, Python goes on to say, to explain why. He says the focus on C was for three main reasons. First, our products, our infrastructure products, and are meant to be simple, fast, and affordable. 42 years plus of experience. And C gives us the ability to squeeze all the performance from any hardware platform. We see the instructions our code will generate and C, C is a great choice for that. Second, if instead of having a set of complex language is each with its own adherence, using a single language removes all the distracting and divisive language wars. Having multiple complex languages create little languages like 4k and the shell script or fine. It's the more complex languages that divide people. Lastly, a single powerful, simple, as opposed to complex language that a single person can maintain. It is essential to our software. I'll tell you a model of doing business, like the workshops of the Renaissance. We have to understand and work on all our own tools. He says, I use Ken's C compiler under Plan 9. It weighs in at a light 20000 lines of code. It goes on to say, over the last 30 years, I carefully chose my foot falls through the software swamp to avoid getting sucked under by one of the quagmire of complexity. Now, the person who wrote this is one of those figures of computer science that you are familiar with the results of his work, but you probably have never heard of him. Key developed the original product called the pics firewall. The company develop that four was then purchased by Cisco to seed the development of Cisco's firewall line. While he was at Cisco, he developed their load balancing techniques. He has he's a holder of some of the patents on techniques like Network Address Translation. The company he currently has is a data storage company that develops systems for large-scale data storage. I really like the way he put this. And I I very much agree with his perspective and his reasons for doing that. I can tell you that when he said specifically no JavaScript and no Python, he did that for a reason. Part of the history of that company was driven by the interests of venture capitalists and the effects that, that had, the consequences in terms of product quality, in terms of corporate direction. We're quite frankly disastrous. And it was clear that the tendency to just grab the most popular newest platform you could was part of the problem. So C becomes for him the improvement for the modern. Why is it so good? Well, one of the things that I like, in fact, this same person name Brantley coil. He told me one day of something that somebody had mentioned to him he really liked. And the rule of thumb went like this. If the language description is more than 50 pages than the language is too complex. And I thought, well that's really cool. Look, I like that. But then I had to stop and think for a while. Well, is that just one of those things? It sounds good? Or is it really true? If it's true, why is it true? And it dawned on me one day that it's because the language cannot be complex. And have you able to hold the whole language in your head. If you can't hold the whole language in your head, then you're constantly stopping to look things up. That kills any possible productivity whatsoever. It would be as if you're trying to write a novel and every third word you have to go to the dictionary to look it up. You have to be able to transcribe the thoughts in your head out through your fingers into the final result. Whether it's music that you're writing or a novel or code, you can't be stopped constantly. Looking up references. Only a simple language will allow you to do that. And see is a beautiful example of that. Another important reason to understand why C is so powerful and so beautiful is if you listen back over what Ken said. He didn't say that we had a group that got together and hammered out a standard for the language. Know, the language was created primarily by one person with one other one giving a lot of feedback. Now the language today has been perverted is about the simplest and least defensive or I can use by various standards committees. Fortunately for us File Dennis was still alive. The respect that people had for him put a damper on some of what happened in those committees. And to a certain degree, nothing really got added to the language while he was alive that he didn't at least tacitly accept. So anything before about 2011 is still reasonably called C. The things since then. Well, we won't get into that. So this video is the first of several that we'll be going into the language and describing how it works and how to use it. I want you to understand that the right way. Not the way that you see it described by people on the Internet. Not the way that you see answers given on Stack Overflow. That's not the right way to understand the C language. Right way to understand the C language is to understand what Brantley said When he said. You can see the instructions. If you truly understand what is going on. When you look at a piece of source code, you don't see the symbols written on paper. You look through the source code and you see what the machine does with it. You see the pictures of the data structures in your head. You see what machine language instructions get executed. It's like those scenes that Hollywood producers where the genius looks off into space. And on the screen you see all these equations floating around. That's kind of the way code is. And if you are good at it, That's what you will do. You will look through the code to see what the machine does. Now, many of you have been told, Oh, you don't need to know what the machine does. We do everything with abstraction. You've been lied to. The word abstraction does not mean you get to ignore what goes on. That's the word for that is ignorance. What abstraction does for you is it allows you to focus your attention on the set of details that are relevant at the moment. If you don't know the details that support and provide the foundation for where you are working. Then you don't know what you're doing. See is a beautiful language for that. The reality is, I don't really care what skills a person has. I don't care what high level abstractions they've memorized. They can memorize the entire Gang of Four book for all I care. And it means nothing to me. If I want to know how good a person is at programming, what I will do is sit down with C. No training wheels. An editor that doesn't format the code for them, that doesn't do syntax highlighting. Know IDE. And I look at the quality of the code they produce. You can produce good quality code with no handholding, with no training wheels. Then you're worthy of the kind of positions I want to hire people for. But if you don't understand the basics, if you don't understand the foundations, you don't understand how all the pieces fit together, then I can't trust you with any of the rest of it. No matter how many abstractions and fancy words you have memorized. I don't care how much you think you're an expert at block chain. I'm not going to hire you if you don't understand the foundations and you don't understand how the pieces fit together. And that's why we're going to focus on c. So let's jump in and take a look at a little bit of C. So I'm going to begin by starting off with everyone's favorite first program. In fact, it's the first program that Kernighan and Ritchie cover in the C programming language book. And that is what we would call hello world. Let's begin. I'm going to use the VI editor here because that's what you're most familiar with at the moment. I personally use other editors more, but we'll go ahead and use VI for now. So we're going to begin with a line here that says include standard io dot h. We're going to begin a thing called main. And boom. Now let's talk through very briefly what we have here. The thing called main is where all programs in C start running. If you have programmed in Java, you're familiar with the idea because there's this thing called main in Java. You have this extremely long list of keywords that introduce it. Let's face it, I'm not smart enough to program in Java. I can't even remember what the sequence of those words. I know there's a static and something else in there. The contents of that is the single statement printf. We're going to get into this in a little bit more detail as things go on. But print f isn't actually a part of the language. The compiler doesn't know about print f Well. A well-written compiler doesn't know about printf. Most modern compilers are somewhat aware of it, but they really shouldn't be. Anyway. It's really a function that exists in a library that we connect to. And an order to know what's available in those libraries. We have these things called header files. And that's what that very first line is doing that pound include standard io dot h. Stdio.h is the name of a file. It's a header file, hence the dot h extension. An std IO refers to a particular subset of what's known as the standard C library. In particular, this is the standard input and output library. And printf is a part of that. So let's save this file and compile it. Now. You say I got nothing printed out. This is correct. This is what you want. Well-written software, particularly systems oriented software, which is of course what we're going to focus on in this class, does not produce extraneous output. It only produces the output that is appropriate to the task. In this case, it's going to generate output in a file, which means nothing gets printed on the screen. So the only time it's going to print something is if there's an error. In this case there were no errors. So it's quite happy. Now where is the file that it created? Well, if I look in here, you'll notice that I have a file called a dot out. That in fact is the file that was just created by running GCC. Gcc. Gcc stands for the GNU C compiler. Well, okay, depending on what context you're talking about it, it also means the good GNU Compiler Collection. Traditionally in Unix. The command for running the C compiler is CC, stands for C compiler, Of course. When new develop their compiler. It was not uncommon to have GCC alongside another version of CC. And so often it was called GCC to differentiate it. And that name has stuck and we still use it. So when I run GCC, it compiles the program. Now what does that mean? It takes the code that I typed in. So let's take a look at that code again. It takes that sequence of ascii characters. And it interprets, it figures out what is being said by them. And it translates that into the binary instructions that the machine understands. The a dot out file contains those binary instructions and some other information we'll get into a little bit later. So let's run the program a dot out. Now, I am prefixing this with the dot slash because this is the, It's a byproduct of the sort of modern sensibilities in the Unix world. That your current directory should not be automatically searched for commands to run, which I'll get into. But let's just say that's typical in most Unix environments today, at least as a default. And that's what you will almost certainly will be seeing when you log into and run things on tux. So let's run our aid, our program. And sure enough it says, Hello World prints out exactly what I told it to. Now, there's one thing a little different between what I told it to print and what you'll see. You'll notice that when I told it to print at the very end, I put this backslash n there. Now you may be familiar with this from other languages you've used. This is the indication of the new line character, the ascii character, which means move the terminal position down to the next line. The normal interpretation of that in a Unix environment is that a carriage return is also added, which is the thing that moves the cursor back to the beginning of the line. So after it's printed out Hello world, we then tell it to go down to the next line. And the underlying mechanism also tells it to go to the beginning of the next line. And that's why my prompt is printed at the beginning of the next line. So when you're generating output, you normally want to put this new line on the end of everything you do. In fact, if you don't, it can lead you to some misleading conclusions. We'll get into things like that a little bit more later. But keep in mind that you aren't necessarily going to see the output appear until a complete line has been generated. And you terminate it with a new line. And then the line may appear on your screen. Okay, So let's talk a little bit more about what's in this file. I've kind of given you the big points of it, but I want to delve into a few more nitty-gritty aspects of the language. Okay, we talked about the idea of what the include stdio.h does. There are a number of these pound sign directives. These are actually not part of what the compiler traditionally sees. These are handled by what's called the c pre-processor. Now, most modern implementations integrate the C preprocessor into the same code as the compiler. But historically it was a completely separate program. And what it does is it literally substitutes the contents of the named file, in this case stdio.h for that line in this File, and then compiles the result. So what the compiler proper actually sees is the entire contents of the file stdio.h followed by the code that I've put here. That's what include actually means. There are a number of other directives, some of which have been abused so badly that when Ken later developed a set of compilers for the Plan 9 operating system, he left out some of what had been there in the past because they become so horribly abused and so poorly. Used. So we're going to be somewhat careful and very specific about which parts of the pre-processor directives we consider. You might guess then that we're only going to be looking at a subset of what is handled or accepted by the, quote unquote, modern compilers like GCC or claim. There are things those compilers except that are not good, see, and we will not be doing them in this class. All right, what about the next bit? These two lines are often put together on one line. This however, is a coding style that I have found quite useful. It is one that I picked up from work done at Bell Labs. Ken Thompson again was involved. Other people, they're like Rob Pike. We're involved with developing the style. And it turns out to be quite handy. Among other things, it makes it very, very easy to search a file for the place that a function is defined as opposed to where it's used. Even if you don't know off the top of your head what the return type is. Because all you have to do is look for that name at the beginning of the line. So what have we got here? The ENT is what is called the return type. This is the data type and mercy added types to be. So it says that main returns an integer. Now what is an integer? An integer is a binary number. Okay? Do not believe that integers inside the computer are inherently base 10 or decimal. They are not. Integers are an abstraction. Physically the representation is binary. The only place base 10 comes into the picture is when we are interacting with a human. So the integer that main returns is simply a binary number. Then we have the name of the function that we are creating. In this case main. We can call functions anything we want. But there is an expectation in the infrastructure in which compiler, C compilers operate that there be a function called main, and that is where the code begins running. And we have some parentheses that follow main. Now in this case, I've made those parentheses empty. What does that mean? Empty parentheses does not mean what you might think. So let's begin with what the parentheses are all about. These are where the parameters are, the arguments to a function or identified. Now, you might think then, okay, if it's an empty set of parentheses, that means there are no arguments or parameters. That's not true. The parentheses being empty means don't check the arguments and parameters. If you literally want to say there are none, then you put the keyword void in there and we'll see some examples of that. The next thing I'll say is that we have this opening curly brace and it's matched with the closing curly brace. Every opening brace needs to have a matching closing brace. We'll talk a little bit about the best way to format those as we go on. Which may not be what you think. These replace. More verbose usage in certain languages like Algol, Pascal, where blocks of code begin with the keyword begin and end with the keyword end. In C, we use the curly braces to group blocks of code. Instead of the words begin and end. Personally, I think it's one of the nicer aspects of the language that it uses more symbolic representations than it does words. I may think. Why is that a good thing? This I kind of picked up on why I like it. This is not the reason I like it isn't what I wasn't this event. This is how I came to understand why out like it. By when I was a freshman in college, got a chance to hear Grace Hopper speak. And in that talk, she said something interesting about languages. And it's important because she is, was a significant role in the development of language cobol and in the development of compilers in general. And in this talk, she said there's essentially two kinds of people in the world. There are those of us that at our heart, our mathematicians. And we want to take all the words and replace them with symbols. And then there's everybody else who want to take all the symbols and turn them into words. Punishment on to say in cobol is for them. So when I heard her say that very much resonated with me and I said, aha, I see, this is why I don't like having lots of words in a language. This is why I like having the symbols instead. And so these braces are a good example of that. Now, the last bit of this, as I've mentioned before, is a function called printf. The F stands for formatted. And the way printf works is you give it a format of how things are to be output and you give it the values that are going to be done in that format. In this case, because what I'm printing is just a literal string. That is the format. And that's all I provide. And you'll notice again, I'm providing it in parentheses. And in this case, I've got the double-quotes. What do double-quotes mean? These are a marker in the language to say that what's contained within them is a stream of ascii characters. And we'll talk about how strings work in the language later. But this is simply saying there does exist some place a literal string which contains the number that represents an uppercase H, followed by the number that represents the lowercase e, et cetera. And then finally, we have the semicolon. This is in C, a statement terminator. So every time a statement is completed, as opposed to a block of statements, every time a single statement is completed, you put a semicolon after it to indicate the end of that statement. So this is everything for why that program works the way it does. So the next step is we're going to look at another program. We're going to write a program that hopefully will look kind of familiar to you. I know that it was mentioned at least in 265 when you took that. And hopefully you remember it. It's called WC stands for word count, but it doesn't just give us a count of words. It also gives us the count of lines and the count of characters. And we're going to develop a version of that program right now. And we're going to do it using the technique of stepwise refinement. That is, we're going to write the program a little bit at a time and debug each piece as we go. So let's jump in and create w c dot c. We will again include standard io dot h. We will again how our main. And we're going to start by simply counting the number of characters in the file. We'll come back and flesh out more capabilities later. So we're going to create an integer called NC. Nc is obviously the number of characters. The fact that we call it an int simply means that it is a binary number where there's no fractional part. It is stored in whatever size of space is a convenient size for this machine to work in. In most environments that you're likely to deal with today. This would be a 32-bit number because we have indicated that it is not unsigned. That is by default they are signed. This means that NC can have a value in the range of negative 2 billion to positive 2 billion plus some other. But again, we're always talking powers of two. So when I say 2 billion, I really mean 2 billion, whatever other digits are necessary. Well, NC, of course, needs to start at 0 because we haven't seen any characters yet. Now, some of you are going to look at that go. But wait a minute. Aren't you supposed to set the initial value and you declare it? No. Yes, you can. And yes, there are people who are very big on doing that. But no, it is not always a good practice. And in fact, I personally find it to be more cluttering and harder to read. So no, I don't think it's a good practice to initialize it in the declaration. The only exception to that are certain languages like limbo and go, where a declaration can be made implicit, such that the type is determined by the type of the assignment. In those cases. I'm okay with having the implicit declaration exist at the same place as the initialization. I'm not a big fan of doing the initialization in the declaration. Otherwise, there are a few occasions when I will do that, but rarely. Now the next thing we want to do is we want to then count the characters, which means we need to do something repeatedly. And the core repetition mechanism in the language is a statement called while. And what this does is it says repeat something as long as a condition is true and we're going to put the condition in parentheses. So I'm going to say while get care is not equal to the file. But what does that mean? So get care, like print f is a function in standard library. It reads a single ascii character from the standard input. Now, it returns however, Full Integer. Now what's the difference? Well, a character is an integer. It's just an integer and a relatively narrow range. All ascii characters are integers between 0 and 127. The character data type that we will see in the language is an eight bit integer, which gives you an, an unsigned case 0 to 255, or signed negative 128 to 127. Get care or however returns a number that is a full integer larger than, say, a 32-bit number, so that we can have a special value to indicate the end of file. You see if get Keras reading from a file that contains other than ascii characters, it might have the entire 256 possible values, in which case, none of those values could tell us we are at the end of file. So get care actually returns of a larger integer. And a special value of that is called EOF to indicate where at the end of file. So for each character that we read, that says we haven't reached the end of file. We're going to increment in C. Now, the plus plus operator in the language means increment, means add 12. Now, one, What? That'll be a little bit interesting later. But in this case, since we're dealing with an ordinary integer, it's one. In this case, our units are characters, so we're adding one character. Now, when we do that, The into file, what do we want to do? Well, we want to print out the count that we just created. So let's print F. Now. I need to print percent d. Now what does that mean? That means I'm printing it in decimal. That does not mean a fractional part. The word decimal does not mean fractional. The word decimal means base ten. Remember I told you that the integer inside of the computer is binary. This tells us to express that binary number as a base 10 numeral. For the human to see. I could do other bases. For example, if I had said percent 0, it would mean octal base 8, or percent x would mean hexadecimal base 16. Percent d means decimal, base 10. And the value I'm going to print in decimal is in C. Okay? Now a few other things about what's happening here. You'll notice that all of the lines except this while have the semicolon. The while line does not have a semicolon. That's important. The reason is that the while is itself not a complete statement. It must have a statement that it operates on. So we do not put a semicolon at the end of the while. What would happen if we did? Well effectively what we would be saying is file is operating on a null statement. The statement that does nothing. So it will repeat nothing until it reaches into file. Maybe we'll take a look at what that does in a minute. Another thing to point out, he knows I have indented things. Unlike Python, the indentation does not itself imply any form of blocking of statements. However, the indentation is absolute. In reasonable programming practice. How far you indent what you use to indent. There are lots of discussions and arguments about that. I myself have varied over the years in the approach that I take. As my level of experience has grown, I have settled on using tabs for the indentation. Whatever you do must be consistent. And furthermore, if you are operating on an existing body of code, it is vital that you maintain the same formatting conventions that are in that code to start with. People get really personal about their formatting styles. And it is quite frankly kind of ridiculous. This is why the developers of the language go decided to eliminate most of the options that people have about formatting and simply declare it must be this certain way or it is wrong. The formatting style that I'm going to be using here is the style used by the people who created C and is also used in go with one small exception. And so this is the style I'm going to be showing you. If you don't like it, you are. I'm not going to require that you use my style. But I am going to suggest that it's not a bad idea to try out several to decide. Okay. So I'm indenting with tabs. The indentation of the in C plus plus under the while is not what makes the in C plus plus part of the while statement. It's the fact that the while has no other statement between it and the in C plus, plus. This is really important and is a big difference for those of you whose primary experience has been Python. Okay, So let's do this program. Now here, I've done something a little bit different. You'll notice in my GCC command I've added this other thing here, this minus o w, c. This overrides. The name of the output file minus o stands for output, and that overrides the name of that. So then instead of creating the file as a dot out, it's going to create the file is w c. And if we look, we see indeed there's a file called w c. So let's one WC. But it need some input. Now, I could just say WC and then just start typing stuff. And then hit the end of that, whoops, to the wrong WC. And say either 27 characters that we counted. Or I could do something like, let's redirect the input. Let's have it run on itself. That is, we're going to have WC count the number of characters in WC dot c, a 1090. This'll be interesting. Let's see what WC does on the binary WC, 16,736. And these numbers, by the way, if we do an ls minus l, are very similar, well, they're exactly the same numbers that we see in though the report from ls. And gives us some confidence that maybe we're doing the right thing, that our code is working correctly. Because CLS, when it finds out the sides of a pile, it does it in a different way than by counting characters. So in fact, we're getting the same result in a different method that suggests that maybe we're getting the right answers. So let's jump back in and do a little bit more stuff with this. So the first thing I'm gonna do is I'm going to come down here and I'm going to say what would happen if I put a semicolon here. Now this time is a little different. I also put a space before the semicolon. Okay. You don't have to. It's a matter of habit and style. And I'll get to that later. But let's say I put the semicolon here. Perhaps it was an error on my part. I wasn't thinking and just added a semicolon. So now let's compile program. And now let's run WC again on its source code. Get one. That's weird. What happens if we run it on the binary? We get one, right? Because if I just run it one, okay, something's wrong. Now let's figure out what. Well, remember what I said was that if we put a semicolon on the while, the thing that gets repeated is nothing a null statement. So once we get to the end of the file, then what happens? Well then we increment in C. And since it started at 0, we increment it by one. Of course we print out a one. So that was clearly not a good move. We don't want that semicolon there on the end of the while. Now, let's do a few other interesting things with this. Let's add the capacity to determine the number of lines in the output. So let's create another variable called an L for number of lines. Also going to create a variable to hold the current character that we're operating on. Now, let's talk a little bit about what I just did here. You'll notice that I did not somehow or another jump down into the middle of the code to create these variables. I went all the way back up to the top of the function and I put the declarations there. Now, some of you from your previous experiences may have even been encouraged to do declarations in the middle of the code. That is horrible. You should not do that. The definition of C, at least as it existed in all of its reasonable implementations, say that the declarations of variables must go at the beginning of a block. And except for certain special cases of machine generated source code. I very strongly expect people to put it at the beginning of the function. Don't declare variables in the middle of the code. That is extremely painful for the reader to come along later and try to figure out where the declaration is. They're looking at a piece of code. They see a particular variable, they need to know what type it was declared as. Where do you find that? Well, naturally you go to the top of the function. Oh no, it's not top of the function. Somewhere between the top of the function and where you were looking to try to figure out what was going on. So why is it that people sometimes encouraged that it's to cover up other bad programming practices. So just don't do it. Now. Another thing here that's important, I've made see an integer, even though we expect it to be a character. Well, that's interesting. Why did I do that? Again, it has to do with this EMF value. So let's jump down into the code. Now. The next thing I'm going to do is I need to make C be the result of the get care. Well, that's kind of interesting. And this is one thing I hate about this editor is highlighting. But let me explain what's happening here. An assignment in C is just an expression. It's not necessarily a statement. So it's perfectly valid to say C equals get care is not equal to EOF. But because of the precedences of the operators, it's necessary to put this set of parentheses around the assignment. So the assignment is done before the comparison to EOF. Now, this aspect of the language where we can do assignments in the middle of conditions. It is a facet of the language that many people consider to be error prone. And there are a lot of circumstances in which we wouldn't necessarily recommend it. On the other hand, it leads to a more concise expression of what it is you're trying to say in what you're doing. We'll talk a little bit in some examples of what is good and what's bad about doing this kind of thing. But for now, I'm going to go ahead and do it this way because you need to at least be able to read it, whether you ever write it this way or not. Okay? Now what else do we need to do? So because we're going to do a number of statements in our loop this time, I need to group them, and that's where the braces come in. Again, remember unlike Python, the indentation does not imply the grouping. The braces imply the grouping. So after I have recognized that it is indeed a character and increment and my characters, I now need to look and ask, does this represent a line? Because I want to increment my number of lines. And the women to do that is I'm going to say, well, if c is equal to the new line character. Now, we're going to have a closing brace. Remember braces have to match up. I'm going to add the printing of the number of lines here. And there's one more thing I need to do to initialize and lt 0. So let's look at what we've got. We've declared all the variables we're going to use. We've initialized in CNN. Well, we don't need to initialize C because the very first thing we ever do with it is a sign it. So we're going to go through this repetition of grabbing a character, asking you, does the file, if it is the file, we're done and we print out our summary. If it's not the end of file, we're going to come down, we're going to increment NC, indicate we've seen a character and they're going to look at that character C. And we're going to ask, was it the end of the line? If it was, then I'll increment my number of lines. Now, this is another important thing with respect to the language that will be different from your experience. If your primary experience with Python, you may remember that in Python, strings can be enclosed in either single quotes or double quotes. And is not the way it works in C. Strings must be in double quotes. Single quotes and c represent a character. And again, what does the character is just a small integer. What is the character? The backslash n represents? That's the ascii value again for the new line. So again, we're looking at integers here. Okay? Let's try this one out. And let's try running it. On. Our WCTC. Says there's 800000 lines and a 174 characters. Well, let's see, does ls agree? Yeah, 174 characters. What about the existing WC on the system? See if that agrees with this 809. Sure enough. Well, that's good. Now, let me show you something else here. When I print it out, the two numbers as percent D is put a backslash t in-between them. That's the tab character. And that's why the output has a pretty good chunk of space between the two numbers. Okay? So let's jump in and make it do one more thing. Let's actually make it count words. Now how are we going to define a word? Particularly for looking at code like this, a o, What are these things? So here's the way we're going to define it. We're basically going to say anything that has whitespace around it. No whitespace being the space character, the tab character, or a new line. So anything that has one of those three is going to be a word. If it's a non-empty string delimited by the whitespace. So how are we going to do that? Well, if you think back to S0, S1, 64, when we talked about state machines, we could have a state machine that tells him I currently in the middle of a word or not in the middle of a word. And every time I see something that's a whitespace character, it means now I'm not in the middle of a word. And every time I see some, there's not a whitespace character. It means I'm now in the middle of a word. And every time I'd make that transition from in a word to not an award. I'll call that a word. So there's our strategy. So here's the way we're gonna do this. We're going to add another count for a number of words. And we're going to add another variable called inward. That's going to be, our state. Tells us, are we in a word or not in a word? So let's initialize those. In W is 0. An inward, we're going to say is also going to start out at 0. Now what we're going to do is come down here and say, well, alright, now, if C is a space or C is a tab, for C is a new line. Then we're going to do something. We're going to increment the number of words. And we're going to say that we're no longer in a word. Otherwise, we're going to say that we are in a word. When I'll wait a minute. That's not going to quite work, Is it? Because if we are currently not in a word, that is we have multiple spaces are multiple tabs. One of those doesn't indicate where. Suddenly starting a word. Do I need to make this a little different, don't I? So what I'm gonna do is I'm going to say I only do these things if I'm in the word. And I'm going to do it this way to illustrate something. First of all, let's go ahead and compile it and test it, and let's see if we're getting the things that actually work. So let's first of all compile and see if we got any errors. We have an error. Good. I needed at least one error somewhere in this particular talk to Help you out. Now, unfortunately, GCC, like many compilers, has developed a tremendous amount of extra garbage that it prints out and the errors. All of this junk right here is trying to point you and tell you where the error in the line is. Is that the training wheels that I talked about? What's important in it is this line right here. And there are several things about it that are important. The first thing to understand is when it says WC dot C colon, that indicates which file the error is in. The first number is the line number where the error exists. We have the word error, sometimes will be warning, and then we have text to describe what the error is. And it says it expected a semicolon before it saw the colon. Hmm. I think that may have been a typo. So let's go to line 20. Sure enough, when we look at this, I typed a colon there instead of a semicolon. So let's change it to semicolon. Now let's compile it again and compiles correctly. Let's try running it again. Oh, look what we forgot. It may have figured out the number of words or may not have. We don't know because we forgot to print them out. So let's do that. So let's come down here and print out the number of lines, I'm sorry, number of words. So I'm going to put those in the middle. So we'll prompt the number lines and boards number of characters. We get. So 69 words. Let's see if that's what the existing WC says. Yup, to the same thing. Now there is one thing here that it would be a little difficult to illustrate, but there's one thing here that it doesn't count. And that is if the final word does not have any whitespace at the end of it, this won't count it. Leave that as an exercise for you to think about what would you change or how could you make it so that that one does get counted as such. All right, so let's take a look at our code again and look at some more features of the C language that we're using here. Now, the first thing that I want to highlight, we didn't really talk about it at the time. But this not equal to that's expressed as exclamation point equal or known as bang equal. As probably familiar to you from other languages that you've used. And it's simply because we don't have a not equal to character in ascii would make sense if we had not equal to character, you'd use it. Unicode has a not equal to character. Why don't we do that? Don't get me started. I had a long talk with some people in the Go development on that and they did not see it my way. And so you can't use the Unicode operators there. I wish you could. Okay. Now, the comparison is double equal. The assignment is single equal. That difference is critical. And as we saw right here, it is legal to do assignments in conditions. So it is legal see, if you were to say see single equal new line. It will not do the right thing. But it is legal in the language. Some people find this to trip them up. They will put single equals in there and then they will try to figure out why they're code's not working. I can tell you that. It's just a question of experience. I can't remember the last time I made that mistake. And I spot them quite quickly when I'm looking at Student Code that and make that mistake. So don't blame the language until you, until you have mastered it. Once you've mastered the language, then you can complain about language, but until then, just improve your abilities. So that's one thing to be careful about. And a lot of people make that mistake, especially when they're beginning. But again, with experience, you won't make that mistake. Another thing that I want to highlight here are these double vertical bars. Those are representing a Boolean or condition. In effect, what it is saying is, if any of those three conditions are true. If c is space, or C is tab, or C is new line. There is a single vertical bar that also means or. But it's used a little bit differently and we'll get to it later. So when you're building conditions in if's and whiles, you're going to typically use these doubled operators. For equality. You're going to have the bang equal for non-equality. You're going to have the double vertical bar for or and a double ampersand for and. Okay, If, and Else. Again, you've seen these in other languages, so I won't belabor exactly how they work. I will say this, that if I had omitted these braces, the first part of the if, then this if statement would have been, again, the thing that was done inside of the true condition of this if but the else would have then been inferred to match up with the inner if, rather than matching up with the outer if. And again, the indentation isn't what tells me that. What tells the human reader that. But what tells the compiler that it's the braces that tell the compiler that. Another thing to notice is you'll notice I went through and I did the indentation by hand. I did not expect or let the editor do it for me. As a general rule, I can't stand editors that do that. I'll let you make your own judgment. But I don't want you to make a judgment until you have developed equal facility both ways. And only when you have developed the ability to do it without the help and to use the editors help. Then decide for yourself. If it makes sense to say, oh, no, I definitely want it to do that. Because if I don't have it, then it's always a nuisance and I can't keep straight. That's not a good answer. That's not a good reason. That's called laziness. Okay. What else about this? There's two more facets of the language I want to highlight here. One is formatting. You'll notice here that I put the opening brace on the same line as the statement that begins the block. I know a lot of people like to do it otherwise. But again, as I said, I am following a style that is what you find in the K in our book. What you find in the code written by Ritchie, Ritchie and Thompson and current Han. And quite frankly, it's to me the most readable style. Furthermore, it is the required style and go. The other facet of the language I want to highlight is in this condition. If inward. You'll notice here that I've got this variable named in the condition and nothing else about it. Well, that implicitly is saying if it's non-zero. In fact, the way if works is it calculates an integer. Remember, everything is a number. So conditions are numbers. And the way the conditions and C are defined is that a true condition? When S1, the conditional operators will give you the value one. A false condition will give you the value 0. The if statement simply asks, is that value 0 or not 0. So anything that's non-zero is considered true and 0 is considered false. Simply knowing that makes this very easy to read. Alright, so that's going to wrap up video one. With respect to the C programming language. I showed you actually enough of the language that you can do. Most things that you might care about doing. But we're going to dig into the other aspects of the language as we go on. Both in terms of data types, in terms of flow control, in terms of structuring code, and, and so on. So until that next video, take care. And I asked you to raise those same hands, please. Thank you. 